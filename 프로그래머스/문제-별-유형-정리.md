## 그리디, 정렬
- 순수 그리디만 생각해서 푸는 경우는 입력 개수가 천 개 이하인 경우

[최솟값 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12941)


## 스택/큐
- 하나씩 검사하면서 조건에 일치하면 스택에 있는 걸 한꺼번에 처리하는 경우

[올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)

## 해시

## 완전탐색, DFS, 백트래킹

## 최단거리, BFS

## 분할정복, 재귀, DP
- 특정 조건을 만족할 때까지 같은 작업을 계속 반복해야 하는 경우
- while문 또는 꼬리재귀만 생각해서 푸는 경우는 입력 개수가 십만 개 이하인 경우
- 아니라면 DP 고려

[이진변환 반복하기](https://school.programmers.co.kr/learn/courses/30/lessons/70129)


## 이진탐색

## 슬라이딩윈도우, 투포인터, 구간 합
- 1차원 배열을 두 번 이상 반복해서 탐색해야 하는 경우
- O(n^2)의 시간복잡도를 O(n)으로 줄일 수 있음

### 슬라이딩 윈도우

### 투포인터
- 부분배열이 연속적이고 가변적인 경우
- 정렬된(연속된) 배열 안에서 2개의 포인터 변수가 각각 시작점과 끝점(arr.length-1)에 위치한 경우
- ex. 연속된 수열 arr에서 전체 합이 n인 부분수열의 개수

[숫자의 표현](https://school.programmers.co.kr/learn/courses/30/lessons/12924)



## 조합, 순열, 중복조합


## 수학
### 소수
### 최대공약수와 최소공배수
### 이진수와 비트연산
- 이진수가 주어지거나 이진수를 반환해야 하는 경우 보통 문자열임. 하지만 join은 성능이 매우 느려 사용하면 시간초과됨
- 그래서 비트 연산 또는 스택을 사용함
- 이진수의 홀짝구분: 마지막 비트(0x1)만 보면 된다. `(num & 0x1) == 0`이면 짝수, 아니면 홀수
- 어떠한 수를 2로 나누고, 그 몫을 또 2로 계속해서 나누면서 나오는 나머지들의 모든 합은 어떠한 수를 이진수로 변환한 수의 1의 개수와 같음
```
// nArr은 정수 n을 이진수로 변환한 배열 ex) n = 5  -> 4+0+1 -> [1,0,1]
nArr.reduce((a,b)=> a + b);
```


## 기타 알고리즘
### 계수정렬
### 캐시
### 쿼드트리
